
<H2><A NAME="SECTION02389000000000000000">
Marshalling</A>
</H2>
Serializar un objeto es convertirlo en una cadena de bytes 
con la idea de almacenarlo para su uso posterior o para
su uso por otro programa o proceso. 
Podemos utilizar el módulo <A NAME="3640"><tex2html_anchor_invisible_mark></A><A NAME="tex2html176"
  HREF="http://ruby-doc.org/core-2.0.0/Marshal.html"><TT>Marshal</TT></A>
para ello.

<P>
Podemos usar marshalling  para guardar el estado de un objeto <tex2html_verb_mark>134<tex2html_verb_mark>:
en un fichero <tex2html_verb_mark>135<tex2html_verb_mark>
<PRE><tex2html_verbatim_mark>verbatim317#</PRE>
La clase <tex2html_verb_mark>136<tex2html_verb_mark> esta definida así:
<PRE><tex2html_verbatim_mark>verbatim318#</PRE>
Podemos cargar posteriormente el objeto
en la ejecución de un script usando <tex2html_verb_mark>137<tex2html_verb_mark>. 
De este modo es posible guardar el estado de un programa entre ejecuciones:

<P>
<PRE><tex2html_verbatim_mark>verbatim319#</PRE>
La ejecución de <tex2html_verb_mark>138<tex2html_verb_mark> serializa el objeto y lo guarda en un fichero:
<PRE><tex2html_verbatim_mark>verbatim320#</PRE>

<P>
La ejecución de <tex2html_verb_mark>139<tex2html_verb_mark> 
reconstruye el objeto usando <tex2html_verb_mark>140<tex2html_verb_mark>:
<PRE><tex2html_verbatim_mark>verbatim321#</PRE>

<P>

<H3><A NAME="SECTION02389100000000000000"><tex2html_anchor_invisible_mark></A>
<A NAME="section:forkandmarshalling"><tex2html_anchor_mark></A><BR>
Marshalling Datos entre Procesos que se Comunican
</H3>

<P>
<PRE><tex2html_verbatim_mark>verbatim322#</PRE>

<UL>
<LI>El método <tex2html_verb_mark>141<tex2html_verb_mark> de <A NAME="3644"><tex2html_anchor_invisible_mark></A><A NAME="tex2html177"
  HREF="http://ruby-doc.org/core-2.0.0/IO.html"><TT>IO</TT></A>
crea un canal y retorna los extremos del mismo.
Es necesario que los dos procesos que usan la pareja para comunicarse cierren el extremo 
del canal que no usen. El extremo de lectura de un canal no generará un
final de fichero si hay escritores que tienen el canal abierto.
En el caso del padre, el <tex2html_verb_mark>142<tex2html_verb_mark> no terminaría nunca 
si no cierra primero el canal de escritura.
</LI>
<LI>En la línea 5, la llamada al método <tex2html_verb_mark>143<tex2html_verb_mark> de la clase <A NAME="3648"><tex2html_anchor_invisible_mark></A><A NAME="tex2html178"
  HREF="http://ruby-doc.org/core-2.0.0/Process.html"><TT>Process</TT></A>
hace que se cree un proceso hijo.
El <tex2html_verb_mark>144<tex2html_verb_mark> retorna al proceso padre el <tex2html_verb_mark>145<tex2html_verb_mark> del proceso hijo.
El proceso hijo recibe un <tex2html_verb_mark>146<tex2html_verb_mark>.
La sintáxis de <tex2html_verb_mark>147<tex2html_verb_mark> es:
<PRE><tex2html_verbatim_mark>verbatim323#</PRE>

<P>
Si se especifica un bloque - como ocurre en el ejemplo -
es el código de ese bloque el que se ejecuta como subproceso. En tal caso
el fin del bloque indica el final del proceso que por defecto termina con un estatus 0.
Por tanto, en este caso, la llamada a <tex2html_verb_mark>148<tex2html_verb_mark> es un exceso y podría ser eliminada, pero es la forma de 
hacer explícita la terminación del proceso.
El proceso padre deberá esperar por la terminación de los procesos hijos usando un <tex2html_verb_mark>149<tex2html_verb_mark>
o bien no esperar usando un <tex2html_verb_mark>150<tex2html_verb_mark> para hacer explícito su desinterés en el estatus del hijo.
La no realización de este protocolo puede conducir a la proliferación de zombies.

<P>
Se puede ver si <tex2html_verb_mark>151<tex2html_verb_mark> está disponible consultando  <tex2html_verb_mark>152<tex2html_verb_mark>.
</LI>
<LI>El método <tex2html_verb_mark>153<tex2html_verb_mark> de la clase 
<A NAME="3652"><tex2html_anchor_invisible_mark></A><A NAME="tex2html179"
  HREF="http://ruby-doc.org/core-2.0.0/Array.html"><TT>Array</TT></A>
tiene la sintáxis:
<PRE><tex2html_verbatim_mark>verbatim324#</PRE>
La llamada empaqueta los contenidos de <tex2html_verb_mark>154<tex2html_verb_mark> en una secuencia 
binaria de acuerdo con las directivas especificadas en
<tex2html_verb_mark>155<tex2html_verb_mark>. 

<P>
Así en la línea:
<PRE><tex2html_verbatim_mark>verbatim325#</PRE>
El formato <tex2html_verb_mark>156<tex2html_verb_mark> en el parámetro de template indica que la cadena binaria producida por 
<tex2html_verb_mark>157<tex2html_verb_mark>será codificada en Base64.

<P>
Base64 denota un grupo de esquemas de codificación que representan datos binarios
en una cadena en formato ASCII.
Estos esquemas se usan cuando hay necesidad de codificar datos binarios que deben 
ser almacenados y transferidos sobre un medio que fué diseñado para tratar con datos de tipo texto.
De esta forma se asegura  que los datos permanecen intactos durante el transporte.
Entre otras aplicaciones, es habitual ver el uso de Base64 en 
el uso de email via MIME y en el almacenamiento de datos complejos en XML.

<P>
En este ejemplo el uso de <tex2html_verb_mark>158<tex2html_verb_mark> y <tex2html_verb_mark>159<tex2html_verb_mark> parece innecesario ya que el canal está ya en un modo de
transmisión binario de manera que caracteres como el retorno de carro o el tabulador no se interpreten.
Se puede eliminar el uso de <tex2html_verb_mark>160<tex2html_verb_mark> y <tex2html_verb_mark>161<tex2html_verb_mark> si se usa <tex2html_verb_mark>162<tex2html_verb_mark>:
<PRE><tex2html_verbatim_mark>verbatim326#</PRE>
y ahora la lectura y reconstrucción de la estructura queda simplificada:
<PRE><tex2html_verbatim_mark>verbatim327#</PRE>
</LI>
<LI>El método <tex2html_verb_mark>163<tex2html_verb_mark> de la clase  <A NAME="3656"><tex2html_anchor_invisible_mark></A><A NAME="tex2html180"
  HREF="http://ruby-doc.org/core-2.0.0/IO.html"><TT>IO</TT></A>
<PRE><tex2html_verbatim_mark>verbatim328#</PRE>

<P>
lee a lo mas <tex2html_verb_mark>164<tex2html_verb_mark> bytes del stream de I/O, o hasta el final de fichero si se omite o es <tex2html_verb_mark>165<tex2html_verb_mark>. 
Si se especifica el <tex2html_verb_mark>166<tex2html_verb_mark>, lo leído se guarda en el mismo.
Cuando el método <tex2html_verb_mark>167<tex2html_verb_mark> alcanza el  final de fichero retorna <tex2html_verb_mark>168<tex2html_verb_mark> o <tex2html_verb_mark>169<tex2html_verb_mark>. 
</LI>
<LI>La llamada al método <tex2html_verb_mark>170<tex2html_verb_mark> de la clase <A NAME="3660"><tex2html_anchor_invisible_mark></A><A NAME="tex2html181"
  HREF="http://ruby-doc.org/core-2.0.0/Process.html"><TT>Process</TT></A>
termina inmediatamente el proceso hijo.
</LI>
<LI>La llamada a <tex2html_verb_mark>171<tex2html_verb_mark>
hace que el proceso padre espere a la salida del proceso hijo.
El método <tex2html_verb_mark>172<tex2html_verb_mark> retorna un array que contiene el 
PID del proceso hijo y su estatus de salida (que es un objeto 
<A NAME="3664"><tex2html_anchor_invisible_mark></A><A NAME="tex2html182"
  HREF="http://http://ruby-doc.org/core-2.0.0/Process/Status.html"><TT>Process::Status</TT></A>).
</LI>
</UL>

<P>
Cuando se ejecuta el programa anterior produce una salida parecida a esta:

<P>
<PRE><tex2html_verbatim_mark>verbatim329#</PRE>

<P>

<H3><A NAME="SECTION02389200000000000000"><tex2html_anchor_invisible_mark></A>
<A NAME="ejercicios:procesos"><tex2html_anchor_mark></A><BR>
Ejercicios
</H3>

<OL>
<LI>¿Que contiene la variable global <tex2html_verb_mark>173<tex2html_verb_mark>?
</LI>
<LI>¿Que contiene la variable global <tex2html_verb_mark>174<tex2html_verb_mark>?
 ¿Cual será la salida?
(Véase <A NAME="3668"><tex2html_anchor_invisible_mark></A><A NAME="tex2html183"
  HREF="http://http://ruby-doc.org/core-2.0.0/Process/Status.html"><TT>Process::Status</TT></A>).
<PRE><tex2html_verbatim_mark>verbatim330#</PRE>
</LI>
<LI>¿Cual será la salida de este programa?
<PRE><tex2html_verbatim_mark>verbatim331#</PRE>
</LI>
<LI>¿Cual será la salida de este programa?
<PRE><tex2html_verbatim_mark>verbatim332#</PRE>
</LI>
<LI>El programa unix <tex2html_verb_mark>175<tex2html_verb_mark> implementa una calculadora. He aqui un ejemplo de sesión
<PRE><tex2html_verbatim_mark>verbatim333#</PRE>
¿Cuál es la salida del siguiente programa?
Véase la documentación de <A NAME="3672"><tex2html_anchor_invisible_mark></A><A NAME="tex2html184"
  HREF="http://ruby-doc.org/core-2.0.0/IO.html#method-c-popen"><TT>popen</TT></A>.
<PRE><tex2html_verbatim_mark>verbatim334#</PRE>
</LI>
</OL>

<P>

<H3><A NAME="SECTION02389300000000000000"><tex2html_anchor_invisible_mark></A>
<A NAME="section:YAML"><tex2html_anchor_mark></A><BR>
Marshalling con YAML
</H3>

<P>
La librería <A NAME="tex2html185"
  HREF="http://ruby-doc.org/stdlib-1.9.3/libdoc/yaml/rdoc/YAML.html"><TT>YAML</TT></A>
nos permite cierta interoperabilidad entre lenguajes.

<P>
La interoperabilidad entre lenguajes es la posibilidad de que el código interactúe con código escrito en un lenguaje de programación diferente. 
La interoperabilidad entre lenguajes puede ayudar a maximizar la reutilización de código y, por tanto, puede mejorar la eficacia del proceso de programación.

<P>
Aquí tenemos un ejemplo:

<P>
<PRE><tex2html_verbatim_mark>verbatim335#</PRE>
Este es el código del script Perl arrancado desde Ruby:
<PRE><tex2html_verbatim_mark>verbatim336#</PRE>
Este es el resultado de la ejecución:
<PRE><tex2html_verbatim_mark>verbatim337#</PRE>

<P>

<H3><A NAME="SECTION02389400000000000000">
Marshalling con PStore</A>
</H3>

<P>
La librería <A NAME="tex2html186"
  HREF="http://ruby-doc.org/stdlib-1.9.3/libdoc/pstore/rdoc/PStore.html"><TT>PStore</TT></A>
nos permite almacenar y recuperar estructuras de datos en un fichero.
<PRE><tex2html_verbatim_mark>verbatim338#</PRE>

<P>
<PRE><tex2html_verbatim_mark>verbatim339#</PRE>
El método <tex2html_verb_mark>176<tex2html_verb_mark>
abre una nueva transacción del almacenamiento de datos.
El código que se pasa como bloque puede leer y escribir datos en el fichero.
El final del bloque produce un commit automático de los cambios.
Es posible producir explícitamente el final de la transacción
llamando a <tex2html_verb_mark>177<tex2html_verb_mark>:
<PRE><tex2html_verbatim_mark>verbatim340#</PRE>
también es posible finalizar la transacción llamando a <tex2html_verb_mark>178<tex2html_verb_mark>:
<PRE><tex2html_verbatim_mark>verbatim341#</PRE>
Si se genera una excepción dentro del bloque se produce una llamada a <tex2html_verb_mark>179<tex2html_verb_mark>.

<P>
Si el argumento <tex2html_verb_mark>180<tex2html_verb_mark> es <tex2html_verb_mark>181<tex2html_verb_mark>, 
sólo se podrá acceder para lectura al almacen de datos durante 
la transacción y cualquier intento de 
cambiarlo producirá una excepción <tex2html_verb_mark>182<tex2html_verb_mark>.

<P>
Nótese que <A NAME="tex2html187"
  HREF="http://ruby-doc.org/stdlib-1.9.3/libdoc/pstore/rdoc/PStore.html"><TT>PStore</TT></A>
no soporta transacciones anidadas.

<P>
El siguiente script recupera los datos almacenados:

<P>
<PRE><tex2html_verbatim_mark>verbatim342#</PRE>

<P>
Sigue un ejemplo de ejecución:

<P>
<PRE><tex2html_verbatim_mark>verbatim343#</PRE>

<P>
<P><DIV><#47773#><B>Ejercicio  <SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">1</SPAN></B><#47773#> &nbsp; 
<#47776#><I>Si se ejecuta por segunda vez:
</I><PRE><tex2html_verbatim_mark>verbatim344#</PRE><I>
Obtenemos:
</I><PRE><tex2html_verbatim_mark>verbatim345#</PRE><I>
¿Cual es la razón?</I><#47776#></DIV><P></P>


<P>

<H3><A NAME="SECTION02389500000000000000"><tex2html_anchor_invisible_mark></A>
<A NAME="susection:marshallinglambdas"><tex2html_anchor_mark></A><BR>
Marshalling Lambdas y Procs
</H3>
Los métodos <tex2html_verb_mark>183<tex2html_verb_mark> y <tex2html_verb_mark>184<tex2html_verb_mark> no funcionan con objetos 
de la clase <A NAME="3685"><tex2html_anchor_invisible_mark></A><A NAME="tex2html188"
  HREF="http://ruby-doc.org/core-2.0.0/Proc.html"><TT>Proc</TT></A>.
Cuando ejecutamos este programa:
<PRE><tex2html_verbatim_mark>verbatim346#</PRE>
Obtenemos un mensaje de error:

<P>
<PRE><tex2html_verbatim_mark>verbatim347#</PRE>

<P>
Algunos objetos no pueden ser volcados. Si nuestra clase tiene necesidades especiales
debemos implementar nuestra propia estrategia de serialización definiendo dos métodos:

<OL>
<LI><tex2html_verb_mark>185<tex2html_verb_mark>

<P>
El método de instancia <tex2html_verb_mark>186<tex2html_verb_mark> debe retornar una cadena <A NAME="3689"><tex2html_anchor_invisible_mark></A><A NAME="tex2html189"
  HREF="http://ruby-doc.org/core-2.0.0/String.html"><TT>String</TT></A>
que contenga la información necesaria para la reconstrucción del objeto hasta 
la profundidad indicada por un parámetro entero.
Un valor de <tex2html_verb_mark>187<tex2html_verb_mark> de dicho parámetro indica que desactivamos la comprobación de profundidad.

<P>
</LI>
<LI><tex2html_verb_mark>188<tex2html_verb_mark>

<P>
El método de clase <tex2html_verb_mark>189<tex2html_verb_mark> toma una <A NAME="3693"><tex2html_anchor_invisible_mark></A><A NAME="tex2html190"
  HREF="http://ruby-doc.org/core-2.0.0/String.html"><TT>String</TT></A>
y devuelve el objeto reconstruido.
</LI>
</OL>

<P>
Veamos un ejemplo de uso de <tex2html_verb_mark>190<tex2html_verb_mark> y <tex2html_verb_mark>191<tex2html_verb_mark>.
La clase <tex2html_verb_mark>192<tex2html_verb_mark> 
permite serializar <A NAME="3697"><tex2html_anchor_invisible_mark></A><A NAME="tex2html191"
  HREF="http://ruby-doc.org/core-2.0.0/Proc.html"><TT>Proc</TT></A>s:

<P>
<PRE><tex2html_verbatim_mark>verbatim348#</PRE>
Este código hace uso de la clase:
<PRE><tex2html_verbatim_mark>verbatim349#</PRE>
Sigue una ejecución:
<PRE><tex2html_verbatim_mark>verbatim350#</PRE>

<P>
Este otro código muestra otra solución que no hace uso de <tex2html_verb_mark>193<tex2html_verb_mark> y <tex2html_verb_mark>194<tex2html_verb_mark>:
<PRE><tex2html_verbatim_mark>verbatim351#</PRE>
La solución ;SPMquot;memoiza;SPMquot; en un hash que es un atributo de la clase la relación entre el fuente y el código.
Cuando se ejecuta el código anterior se obtiene:
<PRE><tex2html_verbatim_mark>verbatim352#</PRE>

<P>

<H3><A NAME="SECTION02389600000000000000"><tex2html_anchor_invisible_mark></A>
   <A NAME="3702"><tex2html_anchor_invisible_mark></A><BR>
Práctica: Procesos Concurrentes
</H3>
  
Generalize el ejemplo visto en la sección <A HREF=<tex2html_cr_mark>#subsection:forkandmarshalling#3382><tex2html_cr_mark></A>
escribiendo un método <tex2html_verb_mark>195<tex2html_verb_mark> que permita lanzar un número dado de procesos:

<P>
<PRE><tex2html_verbatim_mark>verbatim353#</PRE>
Este programa debería producir una salida similar a esta:
<PRE><tex2html_verbatim_mark>verbatim354#</PRE>

<UL>
<LI>Cada lambda es ejecutada en un proceso distinto. 
</LI>
<LI>Las lambdas reciben un único argumento que es la clave
asociada en el hash.
</LI>
<LI>El resultado <tex2html_verb_mark>196<tex2html_verb_mark> devuelto por <tex2html_verb_mark>197<tex2html_verb_mark> será un hash cuyas claves son las mismas que se han pasado como argumentos
y cuyos valores contienen los resultados devueltos por las correspondientes lambdas.
</LI>
<LI>Puede ser útil usar un canal de comunicaciones distinto para cada hijo
</LI>
<LI>El proceso padre deberá sincronizarse con cada uno de los procesos hijos
</LI>
<LI>El valor retornado por <tex2html_verb_mark>198<tex2html_verb_mark> contiene el PID del hijo. Esta información puede ser usada para 
que el proceso padre determine que canal usar para la lectura
</LI>
</UL>

<P>
