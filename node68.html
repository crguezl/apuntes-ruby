<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Marshalling</TITLE>
<META NAME="description" CONTENT="Marshalling">
<META NAME="keywords" CONTENT="perlexamples">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="mystyle.css">

<LINK REL="next" HREF="node69.html">
<LINK REL="previous" HREF="node67.html">
<LINK REL="up" HREF="node59.html">
<LINK REL="next" HREF="node69.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html4016"
  HREF="node69.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html4010"
  HREF="node59.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html4004"
  HREF="node67.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html4012"
  HREF="node769.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html4014"
  HREF="node772.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html29"
  HREF="http://nereida.deioc.ull.es/~lpp/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="LPP"></A><A NAME="tex2html30"
  HREF="http://tinyurl.com/lpp1415"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="LPP moodle"></A><A NAME="tex2html31"
  HREF="https://campusvirtual.ull.es/1415/course/view.php?id=5678"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="SYTW moodle"></A><A NAME="tex2html32"
  HREF="perlexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="pdf"></A><A NAME="tex2html33"
  HREF="https://dl.dropbox.com/u/14539152/LPP/LPPbook/index.html"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html34"
  HREF="http://www.ruby-doc.org/"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html35"
  HREF="http://www.github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="github"></A><A NAME="tex2html36"
  HREF="http://rubylearning.com/blog/"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="blogs"></A><A NAME="tex2html37"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html38"
  HREF="http://www.ull.es/view/centros/etsii/Inicio/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html39"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html40"
  HREF="https://plus.google.com/u/0/communities/115470806071217401678"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="ull-etsii-grado-lpp-1314"></A><A NAME="tex2html41"
  HREF="https://plus.google.com/u/0/communities/109091480492072495700"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="ull-etsii-grado-stw-1314"></A>
<BR>
<B> Siguiente:</B> <A NAME="tex2html4017"
  HREF="node69.html">Objetos Manchados: Tainting</A>
<B> Subir:</B> <A NAME="tex2html4011"
  HREF="node59.html">Objetos</A>
<B> Anterior:</B> <A NAME="tex2html4005"
  HREF="node67.html">Copia de Objetos</A>
 &nbsp; <B>  <A NAME="tex2html4013"
  HREF="node769.html">&#205;ndice General</A></B> 
 &nbsp; <B>  <A NAME="tex2html4015"
  HREF="node772.html">&#205;ndice de Materias</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsecciones</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html4018"
  HREF="node68.html#SECTION02389100000000000000">Marshalling Datos entre Procesos que se Comunican</A>
<LI><A NAME="tex2html4019"
  HREF="node68.html#SECTION02389200000000000000">Ejercicios</A>
<LI><A NAME="tex2html4020"
  HREF="node68.html#SECTION02389300000000000000">Marshalling con YAML</A>
<LI><A NAME="tex2html4021"
  HREF="node68.html#SECTION02389400000000000000">Marshalling con PStore</A>
<LI><A NAME="tex2html4022"
  HREF="node68.html#SECTION02389500000000000000">Marshalling Lambdas y Procs</A>
<LI><A NAME="tex2html4023"
  HREF="node68.html#SECTION02389600000000000000">Práctica: Procesos Concurrentes</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H2><A NAME="SECTION02389000000000000000">
Marshalling</A>
</H2>
Serializar un objeto es convertirlo en una cadena de bytes 
con la idea de almacenarlo para su uso posterior o para
su uso por otro programa o proceso. 
Podemos utilizar el módulo <A NAME="3640"></A><A NAME="tex2html176"
  HREF="http://ruby-doc.org/core-2.0.0/Marshal.html"><TT>Marshal</TT></A>
para ello.

<P>
Podemos usar marshalling  para guardar el estado de un objeto <code>o</code>:
en un fichero <code>objmsh</code>
<PRE>
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n marshal2.rb 
     1  require "Klass"
     2  
     3  o = Klass.new("hello", { :a =&gt; 1, :b =&gt; 2} ) 
     4  File.open("objmsh", "wb") do |f|
     5    data = Marshal.dump(o, f) 
     6  end
</PRE>
La clase <code>Klass</code> esta definida así:
<PRE>
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n Klass.rb 
     1  class Klass 
     2    def initialize(str, hash)
     3      @str, @hash = str, hash 
     4    end 
     5  
     6    def to_s
     7     h = @hash.keys.map { |x| "#{x} =&gt; #{@hash[x]}" }.join(" ")
     8     "str = '#@str' hash = {#{h}}"
     9    end 
    10  end
</PRE>
Podemos cargar posteriormente el objeto
en la ejecución de un script usando <code>Marshal.load</code>. 
De este modo es posible guardar el estado de un programa entre ejecuciones:

<P>
<PRE>
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n marshal3.rb 
     1  require "Klass"
     2  
     3  obj = nil
     4  File.open("objmsh","rb") {|f| obj = Marshal.load(f)}
     5  puts obj.inspect
     6  puts obj
</PRE>
La ejecución de <code>marshal2.rb</code> serializa el objeto y lo guarda en un fichero:
<PRE>
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby marshal2.rb
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ls -ltr | tail -1
-rw-r--r--  1 casianorodriguezleon  staff    43 13 oct 21:29 objmsh
</PRE>

<P>
La ejecución de <code>marshal3.rb</code> 
reconstruye el objeto usando <code>Marshal.load</code>:
<PRE>
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby marshal3.rb
#&lt;Klass:0x10016a020 @hash={:a=&gt;1, :b=&gt;2}, @str="hello"&gt;
str = 'hello' hash = {a =&gt; 1 b =&gt; 2}
</PRE>

<P>

<H3><A NAME="SECTION02389100000000000000"></A>
<A NAME="section:forkandmarshalling"></A>
<BR>
Marshalling Datos entre Procesos que se Comunican
</H3>

<P>
<PRE>
MacBookdeCasiano:distributedRuby casiano$ cat -n fork.rb
     1  #!/usr/bin/env ruby -w
     2  def do_in_child
     3    read, write = IO.pipe
     4  
     5    pid = fork do
     6      read.close
     7      result = yield
     8      write.puts [Marshal.dump(result)].pack("m")
     9      exit!
    10    end
    11  
    12    write.close
    13    puts "In father. PID = #{Process.pid}"
    14    result = read.read
    15    Process.wait2(pid)
    16    r = Marshal.load(result.unpack("m")[0])
    17    puts "#{Process.pid}: #{r.inspect}"
    18  end
    19  
    20  do_in_child do
    21    puts "In child. PID = #{Process.pid}"
    22    { :a =&gt; 1, :b =&gt; 2 } 
    23  end
</PRE>

<UL>
<LI>El método <code>pipe</code> de <A NAME="3644"></A><A NAME="tex2html177"
  HREF="http://ruby-doc.org/core-2.0.0/IO.html"><TT>IO</TT></A>
crea un canal y retorna los extremos del mismo.
Es necesario que los dos procesos que usan la pareja para comunicarse cierren el extremo 
del canal que no usen. El extremo de lectura de un canal no generará un
final de fichero si hay escritores que tienen el canal abierto.
En el caso del padre, el <code>read</code> no terminaría nunca 
si no cierra primero el canal de escritura.
</LI>
<LI>En la línea 5, la llamada al método <code>fork</code> de la clase <A NAME="3648"></A><A NAME="tex2html178"
  HREF="http://ruby-doc.org/core-2.0.0/Process.html"><TT>Process</TT></A>
hace que se cree un proceso hijo.
El <code>fork</code> retorna al proceso padre el <code>PID</code> del proceso hijo.
El proceso hijo recibe un <code>nil</code>.
La sintáxis de <code>fork</code> es:
<PRE>
  fork [{ block }] → fixnum or nil
</PRE>

<P>
Si se especifica un bloque - como ocurre en el ejemplo -
es el código de ese bloque el que se ejecuta como subproceso. En tal caso
el fin del bloque indica el final del proceso que por defecto termina con un estatus 0.
Por tanto, en este caso, la llamada a <code>exit!</code> es un exceso y podría ser eliminada, pero es la forma de 
hacer explícita la terminación del proceso.
El proceso padre deberá esperar por la terminación de los procesos hijos usando un <code>wait</code>
o bien no esperar usando un <code>detach</code> para hacer explícito su desinterés en el estatus del hijo.
La no realización de este protocolo puede conducir a la proliferación de zombies.

<P>
Se puede ver si <code>fork</code> está disponible consultando  <code>Process.respond_to?(:fork)</code>.
</LI>
<LI>El método <code>pack</code> de la clase 
<A NAME="3652"></A><A NAME="tex2html179"
  HREF="http://ruby-doc.org/core-2.0.0/Array.html"><TT>Array</TT></A>
tiene la sintáxis:
<PRE>
  arr.pack ( aTemplateString ) -&gt; aBinaryString
</PRE>
La llamada empaqueta los contenidos de <code>arr</code> en una secuencia 
binaria de acuerdo con las directivas especificadas en
<code>aTemplateString</code>. 

<P>
Así en la línea:
<PRE>
     write.puts [Marshal.dump(result)].pack("m")
</PRE>
El formato <code>"m"</code> en el parámetro de template indica que la cadena binaria producida por 
<code>Marshal.dump(result)</code>será codificada en Base64.

<P>
Base64 denota un grupo de esquemas de codificación que representan datos binarios
en una cadena en formato ASCII.
Estos esquemas se usan cuando hay necesidad de codificar datos binarios que deben 
ser almacenados y transferidos sobre un medio que fué diseñado para tratar con datos de tipo texto.
De esta forma se asegura  que los datos permanecen intactos durante el transporte.
Entre otras aplicaciones, es habitual ver el uso de Base64 en 
el uso de email via MIME y en el almacenamiento de datos complejos en XML.

<P>
En este ejemplo el uso de <code>pack</code> y <code>unpack</code> parece innecesario ya que el canal está ya en un modo de
transmisión binario de manera que caracteres como el retorno de carro o el tabulador no se interpreten.
Se puede eliminar el uso de <code>pack</code> y <code>unpack</code> si se usa <code>syswrite</code>:
<PRE>
 8     write.syswrite Marshal.dump(result)
</PRE>
y ahora la lectura y reconstrucción de la estructura queda simplificada:
<PRE>
 14   result = read.read
 15   Process.wait2(pid)
 16   r = Marshal.load(result)
</PRE>
</LI>
<LI>El método <code>read</code> de la clase  <A NAME="3656"></A><A NAME="tex2html180"
  HREF="http://ruby-doc.org/core-2.0.0/IO.html"><TT>IO</TT></A>
<PRE>
  read([length [, buffer]]) =&gt; string, buffer, or nil
</PRE>

<P>
lee a lo mas <code>length</code> bytes del stream de I/O, o hasta el final de fichero si se omite o es <code>nil</code>. 
Si se especifica el <code>buffer</code>, lo leído se guarda en el mismo.
Cuando el método <code>read</code> alcanza el  final de fichero retorna <code>nil</code> o <code>""</code>. 
</LI>
<LI>La llamada al método <code>exit!</code> de la clase <A NAME="3660"></A><A NAME="tex2html181"
  HREF="http://ruby-doc.org/core-2.0.0/Process.html"><TT>Process</TT></A>
termina inmediatamente el proceso hijo.
</LI>
<LI>La llamada a <code>wait2</code>
hace que el proceso padre espere a la salida del proceso hijo.
El método <code>wait2</code> retorna un array que contiene el 
PID del proceso hijo y su estatus de salida (que es un objeto 
<A NAME="3664"></A><A NAME="tex2html182"
  HREF="http://http://ruby-doc.org/core-2.0.0/Process/Status.html"><TT>Process::Status</TT></A>).
</LI>
</UL>

<P>
Cuando se ejecuta el programa anterior produce una salida parecida a esta:

<P>
<PRE>
MacBookdeCasiano:distributedRuby casiano$ ./fork.rb 
In father. PID = 6583
In child. PID = 6584
6583: {:a=&gt;1, :b=&gt;2}
</PRE>

<P>

<H3><A NAME="SECTION02389200000000000000"></A>
<A NAME="ejercicios:procesos"></A>
<BR>
Ejercicios
</H3>

<OL>
<LI>¿Que contiene la variable global <code>$$</code>?
</LI>
<LI>¿Que contiene la variable global <code>$?</code>?
 ¿Cual será la salida?
(Véase <A NAME="3668"></A><A NAME="tex2html183"
  HREF="http://http://ruby-doc.org/core-2.0.0/Process/Status.html"><TT>Process::Status</TT></A>).
<PRE>
&gt;&gt; `ls noexiste`
ls: noexiste: No such file or directory
=&gt; ""
&gt;&gt; $?
=&gt; #&lt;Process::Status: pid=1717,exited(1)&gt;
&gt;&gt; $?.exitstatus
=&gt; 
&gt;&gt; $?.pid
=&gt; 
&gt;&gt; $?.signaled?
=&gt; false
&gt;&gt; $?.success?
=&gt; 
&gt;&gt; $?.termsig
=&gt; nil
</PRE>
</LI>
<LI>¿Cual será la salida de este programa?
<PRE>
if (pid = fork) then puts $$ else puts $$ end
</PRE>
</LI>
<LI>¿Cual será la salida de este programa?
<PRE>
     1  a = 4
     2  if (pid = fork)
     3    puts "#{$$}: #{a}"
     4  else 
     5    puts "#{$$}: #{a}"
     6    a  = 5
     7    puts "#{$$}: #{a}"
     8    exit!
     9  end
    10  Process.wait2
    11  puts "#{$$}: #{a}"
</PRE>
</LI>
<LI>El programa unix <code>bc</code> implementa una calculadora. He aqui un ejemplo de sesión
<PRE>
~/rubytesting/distributedRuby$ bc
bc 1.06
Copyright 1991-1994, 1997, 1998, 2000 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'. 
a = 2*-4
a
-8      
b = 9+a
b
1
^D
~/rubytesting/distributedRuby$
</PRE>
¿Cuál es la salida del siguiente programa?
Véase la documentación de <A NAME="3672"></A><A NAME="tex2html184"
  HREF="http://ruby-doc.org/core-2.0.0/IO.html#method-c-popen"><TT>popen</TT></A>.
<PRE>
~/rubytesting/distributedRuby$ cat -n bc.rb 
     1  IO.popen("bc", "r+") do |pipe|
     2    pipe.puts("a = 2*-4")
     3    pipe.puts("a")
     4    output = pipe.gets
     5    puts output
     6  
     7    pipe.puts("b = 9+a")
     8    pipe.puts("b")
     9    pipe.close_write  
    10    output = pipe.gets
    11    puts output
    12  end
</PRE>
</LI>
</OL>

<P>

<H3><A NAME="SECTION02389300000000000000"></A>
<A NAME="section:YAML"></A>
<BR>
Marshalling con YAML
</H3>

<P>
La librería <A NAME="tex2html185"
  HREF="http://ruby-doc.org/stdlib-1.9.3/libdoc/yaml/rdoc/YAML.html"><TT>YAML</TT></A>
nos permite cierta interoperabilidad entre lenguajes.

<P>
La interoperabilidad entre lenguajes es la posibilidad de que el código interactúe con código escrito en un lenguaje de programación diferente. 
La interoperabilidad entre lenguajes puede ayudar a maximizar la reutilización de código y, por tanto, puede mejorar la eficacia del proceso de programación.

<P>
Aquí tenemos un ejemplo:

<P>
<PRE>
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n marshallingWithYAML.rb 
     1  require 'YAML'
     2  
     3  fred = {}
     4  fred['name'] = "Fred Astair"
     5  fred['age'] = 54
     6  
     7  laura = {}
     8  laura['name'] = "Laura Higgins"
     9  laura['age'] = 45
    10  
    11  test_data = [ fred, laura ]
    12  
    13  puts "The array dumped by Ruby in YAML format:\n"+YAML::dump(test_data)
    14  
    15  IO.popen('perl perlscript.pl', "w+") do |pipe|
    16    pipe.puts YAML::dump(test_data)
    17    pipe.close_write  
    18    output = pipe.read
    19    puts "The perl script produced this output:\n&lt;&lt;\n#{output}&gt;&gt;"
    20  end
</PRE>
Este es el código del script Perl arrancado desde Ruby:
<PRE>
/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n perlscript.pl 
     1  use strict;
     2  use warnings;
     3  $| = 1;
     4  
     5  use YAML;
     6  
     7  $/ = undef;
     8  my $rubypersons = &lt;STDIN&gt;;
     9  my $perlpersons = Load($rubypersons);
    10  for (@$perlpersons) {
    11    print($_-&gt;{name},"\n");
    12  }
</PRE>
Este es el resultado de la ejecución:
<PRE>
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby marshallingWithYAML.rb 
The array dumped by Ruby in YAML format:
--- 
- name: Fred Astair
  age: 54
- name: Laura Higgins
  age: 45
The perl script produced this output:
&lt;&lt;
Fred Astair
Laura Higgins
&gt;&gt;
</PRE>

<P>

<H3><A NAME="SECTION02389400000000000000">
Marshalling con PStore</A>
</H3>

<P>
La librería <A NAME="tex2html186"
  HREF="http://ruby-doc.org/stdlib-1.9.3/libdoc/pstore/rdoc/PStore.html"><TT>PStore</TT></A>
nos permite almacenar y recuperar estructuras de datos en un fichero.
<PRE>
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n trivialclass.rb 
     1  class Person
     2    attr_accessor :name, :job, :gender, :age
     3  end
</PRE>

<P>
<PRE>
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n marshalWithPStore.rb
     1  require "trivialclass"
     2  require "pstore"
     3  
     4  fred = Person.new
     5  fred.name = 'Fred Bloggs'
     6  fred.age = 54
     7  
     8  laura = Person.new
     9  laura.name = "Laura Higgins"
    10  laura.age = 45
    11  
    12  store = PStore.new("persistentobjects")
    13  store.transaction do
    14    store[:people] ||= []
    15    store[:people] &lt;&lt; fred &lt;&lt; laura
    16  end
</PRE>
El método <code>transaction(read_only=false)</code>
abre una nueva transacción del almacenamiento de datos.
El código que se pasa como bloque puede leer y escribir datos en el fichero.
El final del bloque produce un commit automático de los cambios.
Es posible producir explícitamente el final de la transacción
llamando a <code>PStore::commit</code>:
<PRE>
require "pstore"

store = PStore.new("data_file.pstore")
store.transaction do  # begin transaction
  # load some data into the store...
  store[:one] = 1
  store[:two] = 2

  store.commit        # end transaction here, committing changes

  store[:three] = 3   # this change is never reached
end
</PRE>
también es posible finalizar la transacción llamando a <code>abort</code>:
<PRE>
require "pstore"

store = PStore.new("data_file.pstore")
store.transaction do  # begin transaction
  store[:one] = 1     # this change is not applied, see below...
  store[:two] = 2     # this change is not applied, see below...

  store.abort         # end transaction here, discard all changes

  store[:three] = 3   # this change is never reached
end
</PRE>
Si se genera una excepción dentro del bloque se produce una llamada a <code>abort</code>.

<P>
Si el argumento <code>read_only</code> es <code>true</code>, 
sólo se podrá acceder para lectura al almacen de datos durante 
la transacción y cualquier intento de 
cambiarlo producirá una excepción <code>PStore::Error</code>.

<P>
Nótese que <A NAME="tex2html187"
  HREF="http://ruby-doc.org/stdlib-1.9.3/libdoc/pstore/rdoc/PStore.html"><TT>PStore</TT></A>
no soporta transacciones anidadas.

<P>
El siguiente script recupera los datos almacenados:

<P>
<PRE>
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ cat -n useMarshalWithPStore.rb
     1  require "trivialclass"
     2  require "pstore"
     3  store = PStore.new("persistentobjects")
     4  people = []
     5  store.transaction do
     6    people = store[:people]
     7  end
     8  people.each { |o|
     9    puts o.inspect
    10  }
</PRE>

<P>
Sigue un ejemplo de ejecución:

<P>
<PRE>
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby marshalWithPStore.rb 
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ls -ltr | tail -1
-rw-r--r--  1 casianorodriguezleon  staff    77 16 oct 12:48 persistentobjects
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby useMarshalWithPStore.rb 
#&lt;Person:0x10036ee48 @name="Fred Bloggs", @age=54&gt;
#&lt;Person:0x10036ed80 @name="Laura Higgins", @age=45&gt;
</PRE>

<P>
<P>
<DIV><B>Ejercicio  <SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">1</SPAN></B> &nbsp; 
<I>Si se ejecuta por segunda vez:
</I><PRE>
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby marshalWithPStore.rb 
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ls -ltr | tail -1
-rw-r--r--  1 casianorodriguezleon  staff   125 16 oct 12:49 persistentobjects
</PRE><I>
Obtenemos:
</I><PRE>
~/rubytesting/TheRubyProgrammingLanguage/Chapter7ClassesAndModules$ ruby useMarshalWithPStore.rb 
#&lt;Person:0x10036ee48 @name="Fred Bloggs", @age=54&gt;
#&lt;Person:0x10036ed80 @name="Laura Higgins", @age=45&gt;
#&lt;Person:0x10036ed08 @name="Fred Bloggs", @age=54&gt;
#&lt;Person:0x10036ec90 @name="Laura Higgins", @age=45&gt;
</PRE><I>
¿Cual es la razón?</I></DIV><P></P>

<P>

<H3><A NAME="SECTION02389500000000000000"></A>
<A NAME="susection:marshallinglambdas"></A>
<BR>
Marshalling Lambdas y Procs
</H3>
Los métodos <code>dump</code> y <code>load</code> no funcionan con objetos 
de la clase <A NAME="3685"></A><A NAME="tex2html188"
  HREF="http://ruby-doc.org/core-2.0.0/Proc.html"><TT>Proc</TT></A>.
Cuando ejecutamos este programa:
<PRE>
~/rubytesting/distributedRuby/serializeProc$ cat -n marshal2.rb 
     1  o = Proc.new { |a,b | a+b }  
     2  File.open("objmsh", "wb") do |f|
     3    data = Marshal.dump(o, f) 
     4  end
</PRE>
Obtenemos un mensaje de error:

<P>
<PRE>
~/rubytesting/distributedRuby/serializeProc$ ruby marshal2.rb 
marshal2.rb:3:in `dump': no marshal_dump is defined for class Proc (TypeError)
  from marshal2.rb:3
  from marshal2.rb:2:in `open'
  from marshal2.rb:2
</PRE>

<P>
Algunos objetos no pueden ser volcados. Si nuestra clase tiene necesidades especiales
debemos implementar nuestra propia estrategia de serialización definiendo dos métodos:

<OL>
<LI><code>_dump</code>

<P>
El método de instancia <code>_dump</code> debe retornar una cadena <A NAME="3689"></A><A NAME="tex2html189"
  HREF="http://ruby-doc.org/core-2.0.0/String.html"><TT>String</TT></A>
que contenga la información necesaria para la reconstrucción del objeto hasta 
la profundidad indicada por un parámetro entero.
Un valor de <code>-1</code> de dicho parámetro indica que desactivamos la comprobación de profundidad.

<P>
</LI>
<LI><code>_load</code>

<P>
El método de clase <code>_load</code> toma una <A NAME="3693"></A><A NAME="tex2html190"
  HREF="http://ruby-doc.org/core-2.0.0/String.html"><TT>String</TT></A>
y devuelve el objeto reconstruido.
</LI>
</OL>

<P>
Veamos un ejemplo de uso de <code>_dump</code> y <code>_load</code>.
La clase <code>SerializableProc</code> 
permite serializar <A NAME="3697"></A><A NAME="tex2html191"
  HREF="http://ruby-doc.org/core-2.0.0/Proc.html"><TT>Proc</TT></A>s:

<P>
<PRE>
~/rubytesting/distributedRuby/serializeProc$ cat -n SerializableProc.rb 
     1  class SerializableProc
     2  
     3     def initialize( block )
     4       @block = block
     5       @block.sub!(/^/,'lambda ') unless @block =~/^\s*(?:lambda|proc)/
     6       # Test if block is valid.
     7       @func = eval "#{@block}"
     8     end
     9  
    10  
    11     def call(* args)
    12       @func.call(* args)
    13     end
    14  
    15     def arity
    16       @func.arity
    17     end
    18  
    19     def _dump(limit)
    20       @block
    21     end
    22  
    23     def self._load(s)
    24       self.new(s)
    25     end
    26  
    27  end
</PRE>
Este código hace uso de la clase:
<PRE>
~/rubytesting/distributedRuby/serializeProc$ cat -n marshalproc2.rb 
     1  
     2  require "SerializableProc"
     3  
     4  
     5  if $0 == __FILE__
     6  
     7     code = SerializableProc.new %q{ { |a,b| a+b }}
     8  
     9     # Marshal
    10     File.open('proc.marshalled', 'w') { |file| Marshal.dump(code, file) }
    11     code = File.open('proc.marshalled') { |file| Marshal.load(file) }
    12  
    13     p code.call( 1, 2 )
    14  
    15     p code.arity
    16  
    17  end
</PRE>
Sigue una ejecución:
<PRE>
~/rubytesting/distributedRuby/serializeProc$ ruby marshalproc2.rb 
3
2
</PRE>

<P>
Este otro código muestra otra solución que no hace uso de <code>_dump</code> y <code>_load</code>:
<PRE>
~/rubytesting/distributedRuby/serializeProc$ cat -n serializableProc2.rb 
     1  class SerializableProc
     2  
     3     @@cache = {}
     4     def initialize( block )
     5       @block = block
     6       @block.sub!(/^/,'lambda ') unless @block =~/^\s*(?:lambda|proc)/
     7       # Test if block is valid.
     8       @@cache[@block] = eval "#{@block}"
     9     end
    10  
    11  
    12     def call(* args)
    13       @@cache[@block].call(* args)
    14     end
    15  
    16     def arity
    17       @@cache[@block].arity
    18     end
    19  
    20  end
    21  
    22  
    23  if $0 == __FILE__
    24  
    25     require 'yaml'
    26     require 'pstore'
    27  
    28     code = SerializableProc.new %q{ { |a,b| a+b }}
    29  
    30     # Marshal
    31     File.open('proc.marshalled', 'w') { |file| Marshal.dump(code, file) }
    32     code = File.open('proc.marshalled') { |file| Marshal.load(file) }
    33  
    34     p code.call( 1, 2 )
    35  
    36     # PStore
    37     store = PStore.new('proc.pstore')
    38     store.transaction do
    39       store['proc'] = code
    40     end
    41     store.transaction do
    42       code = store['proc']
    43     end
    44  
    45     p code.call( 1, 2 )
    46  
    47     # YAML
    48     File.open('proc.yaml', 'w') { |file| YAML.dump(code, file) }
    49     code = File.open('proc.yaml') { |file| YAML.load(file) }
    50  
    51     p code.call( 1, 2 )
    52  
    53     p code.arity
    54  
    55  end
</PRE>
La solución "memoiza" en un hash que es un atributo de la clase la relación entre el fuente y el código.
Cuando se ejecuta el código anterior se obtiene:
<PRE>
~/rubytesting/distributedRuby/serializeProc$ ruby serializableProc2.rb 
3
3
3
2
</PRE>

<P>

<H3><A NAME="SECTION02389600000000000000"></A>
   <A NAME="3702"></A>
<BR>
Práctica: Procesos Concurrentes
</H3>
  
Generalize el ejemplo visto en la sección <A HREF="#subsection:forkandmarshalling"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
escribiendo un método <code>prun</code> que permita lanzar un número dado de procesos:

<P>
<PRE>
res = prun(
     :one     =&gt; lambda { |n| "#{n} is 1" },
     :three   =&gt; lambda { |n| "#{n} is 3" },
     'two'    =&gt; lambda { |n| n*4 }
)

puts res.inspect

res = prun(
     [2, 3, 7] =&gt; lambda { |n| n[0]+n[1]+n[2] },
     [4, 5]    =&gt; lambda { |n| n[0]*n[1] }
)

puts res.inspect
</PRE>
Este programa debería producir una salida similar a esta:
<PRE>
~/rubytesting/distributedRuby$ ruby parfork2.rb 
{"two"=&gt;"twotwotwotwo", :one=&gt;"one is 1", :three=&gt;"three is 3"}
{[2, 3, 7]=&gt;12, [4, 5]=&gt;20}
</PRE>

<UL>
<LI>Cada lambda es ejecutada en un proceso distinto. 
</LI>
<LI>Las lambdas reciben un único argumento que es la clave
asociada en el hash.
</LI>
<LI>El resultado <code>res</code> devuelto por <code>prun</code> será un hash cuyas claves son las mismas que se han pasado como argumentos
y cuyos valores contienen los resultados devueltos por las correspondientes lambdas.
</LI>
<LI>Puede ser útil usar un canal de comunicaciones distinto para cada hijo
</LI>
<LI>El proceso padre deberá sincronizarse con cada uno de los procesos hijos
</LI>
<LI>El valor retornado por <code>wait2</code> contiene el PID del hijo. Esta información puede ser usada para 
que el proceso padre determine que canal usar para la lectura
</LI>
</UL>

<P>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html4016"
  HREF="node69.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html4010"
  HREF="node59.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html4004"
  HREF="node67.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html4012"
  HREF="node769.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A> 
<A NAME="tex2html4014"
  HREF="node772.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.png"></A> <A NAME="tex2html29"
  HREF="http://nereida.deioc.ull.es/~lpp/index.html"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="logoLPP.png"
 ALT="LPP"></A><A NAME="tex2html30"
  HREF="http://tinyurl.com/lpp1415"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="LPP moodle"></A><A NAME="tex2html31"
  HREF="https://campusvirtual.ull.es/1415/course/view.php?id=5678"><IMG
  WIDTH="50" ALIGN="BOTTOM" BORDER="0"
 SRC="moodleLHPlogo.jpeg"
 ALT="SYTW moodle"></A><A NAME="tex2html32"
  HREF="perlexamples.pdf"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="pdf"></A><A NAME="tex2html33"
  HREF="https://dl.dropbox.com/u/14539152/LPP/LPPbook/index.html"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="ruby gems"></A><A NAME="tex2html34"
  HREF="http://www.ruby-doc.org/"><IMG
  WIDTH="30" ALIGN="BOTTOM" BORDER="0"
 SRC="perlonion.jpeg"
 ALT="perldoc"></A><A NAME="tex2html35"
  HREF="http://www.github.com"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="google-code-project-hosting.jpeg"
 ALT="github"></A><A NAME="tex2html36"
  HREF="http://rubylearning.com/blog/"><IMG
  WIDTH="27" ALIGN="BOTTOM" BORDER="0"
 SRC="perl6.jpg"
 ALT="blogs"></A><A NAME="tex2html37"
  HREF="http://www.google.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ggoogle.gif"
 ALT="google"></A><A NAME="tex2html38"
  HREF="http://www.ull.es/view/centros/etsii/Inicio/es"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="etsii.png"
 ALT="etsii"></A><A NAME="tex2html39"
  HREF="http://www.ull.es/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="ull.gif"
 ALT="ull"></A><A NAME="tex2html40"
  HREF="https://plus.google.com/u/0/communities/115470806071217401678"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="ull-etsii-grado-lpp-1314"></A><A NAME="tex2html41"
  HREF="https://plus.google.com/u/0/communities/109091480492072495700"><IMG
  WIDTH="32" ALIGN="BOTTOM" BORDER="0"
 SRC="logopcgull.gif"
 ALT="ull-etsii-grado-stw-1314"></A>
<BR>
<B> Siguiente:</B> <A NAME="tex2html4017"
  HREF="node69.html">Objetos Manchados: Tainting</A>
<B> Subir:</B> <A NAME="tex2html4011"
  HREF="node59.html">Objetos</A>
<B> Anterior:</B> <A NAME="tex2html4005"
  HREF="node67.html">Copia de Objetos</A>
 &nbsp; <B>  <A NAME="tex2html4013"
  HREF="node769.html">&#205;ndice General</A></B> 
 &nbsp; <B>  <A NAME="tex2html4015"
  HREF="node772.html">&#205;ndice de Materias</A></B> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
Casiano Rodriguez León
2014-09-11
</ADDRESS>
</BODY>
</HTML>
