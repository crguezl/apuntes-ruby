
<H2><A NAME="SECTION027174000000000000000">
La Clase Player: Un Ejemplo de <SPAN  CLASS="textbf">Strategy Pattern</SPAN></A>
</H2>

<P>
El concepto de jugador es definido mediante una clase abstracta:

<P>
<PRE><tex2html_verbatim_mark>verbatim932#</PRE>
de la que heredan los jugadores concretos.

<P>
Cada jugador es una clase. Por ejemplo, el jugador humano:
<PRE><tex2html_verbatim_mark>verbatim933#</PRE>
Un par de jugadores mas, uno tonto y otro listo:
<PRE><tex2html_verbatim_mark>verbatim934#</PRE>
La Banda de los Cuatro (<A NAME="7827"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textbf">The Gang of Four</SPAN> o <A NAME="7829"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textbf">GoF</SPAN>) 
llama a esta idea de <SPAN  CLASS="textbf">implanta el algoritmo en clases separadas</SPAN> el 
<A NAME="7831"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textbf">strategy pattern</SPAN> o <A NAME="7833"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textbf">patrón estrategia</SPAN> [#DPR#<tex2html_cite_mark>#1##<tex2html_cite_mark>#], [#GO4#<tex2html_cite_mark>#1##<tex2html_cite_mark>#].
Esta estrategia puede aplicarse cuando ocurre que en medio de nuestra aplicación
tenemos una parte que varía (el tipo de jugador). 
A veces en esa parte queremos  hacer una cosa (usar el jugador <tex2html_verb_mark>967<tex2html_verb_mark>) y a veces
otra (el jugador <tex2html_verb_mark>968<tex2html_verb_mark>). Es mas, es seguro que en el futuro se querrá
otra cosa (¿que tal un jugador <tex2html_verb_mark>969<tex2html_verb_mark>?).

<OL>
<LI>La idea clave es definir una familia de clases, las <A NAME="7835"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textbf">strategy</SPAN>
o <A NAME="7837"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textbf">estrategias</SPAN> que hacen de distintas formas la misma cosa:
en nuestro ejemplo son los distintos tipos de <tex2html_verb_mark>970<tex2html_verb_mark> que lo
que hacen es decidir la próxima jugada mediante  <tex2html_verb_mark>971<tex2html_verb_mark>.
</LI>
<LI>No sólo realizan la misma tarea sino que comparten la misma interfaz definida por la
clase <tex2html_verb_mark>972<tex2html_verb_mark>.
</LI>
<LI>Dado que todos los objetos <A NAME="7839"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textbf">strategy</SPAN>
tiene la misma pinta vistos desde fuera, pueden ser usados
por el usuario de la estrategia - Al que la GoF denomina <A NAME="7841"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textbf">context</SPAN>
o <A NAME="7843"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textbf">contexto</SPAN> - como partes intercambiables. En nuestro caso el context
es la clase 
<tex2html_verb_mark>973<tex2html_verb_mark>, que usa los <tex2html_verb_mark>974<tex2html_verb_mark>s como objetos intercambiables
</LI>
<LI>Al separar la clase cliente <tex2html_verb_mark>975<tex2html_verb_mark> - el contexto -
de las clases estrategia <tex2html_verb_mark>976<tex2html_verb_mark>s es necesario habilitar un mecanismo 
de comunicación entre el contexto y la estrategia. En este ejemplo se ha optado por 
pasar  esa información - el tablero - como argumento:
<PRE><tex2html_verbatim_mark>verbatim935#</PRE>
La estrategia - el jugador <tex2html_verb_mark>977<tex2html_verb_mark> - recibe el tablero <tex2html_verb_mark>978<tex2html_verb_mark> 
y retorna su decisión - la jugada <tex2html_verb_mark>979<tex2html_verb_mark> (algo como <tex2html_verb_mark>980<tex2html_verb_mark>)
</LI>
<LI>Un ejemplo de uso práctico del patrón Strategy puede verse en el código de <tex2html_verb_mark>981<tex2html_verb_mark>, 
la herramienta que se usa en Ruby para extraer documentación
de los programas: por un lado hay una variación en los parsers que soporta: C, Ruby y FORTRAN.
Por otro lado la salida puede hacerse en diversos formatos: XML, distintas versiones de HTML, CHM, <tex2html_verb_mark>982<tex2html_verb_mark>, etc.
En <tex2html_verb_mark>983<tex2html_verb_mark> cada uno de los formatos de salida es manejado mediante una estrategia.
</LI>
</OL>

<P>
