
<H2><A NAME="SECTION02384000000000000000"><tex2html_anchor_invisible_mark></A>
<A NAME="claseytipodeunobjeto"><tex2html_anchor_mark></A><BR>
Clase y Tipo de un Objeto
</H2>

<P>
To determine the class of an object in Ruby,
simply ask for it:

<P>
<PRE><tex2html_verbatim_mark>verbatim301#</PRE>

<P>
We can
ask any class what its superclass is:

<P>
<PRE><tex2html_verbatim_mark>verbatim302#</PRE>

<P>
In Ruby 1.9, Object is no longer the root of the class hierarchy:

<P>
<PRE><tex2html_verbatim_mark>verbatim303#</PRE>

<P>
So a particularly straightforward way to check the class of an
object is by direct comparison:

<P>
<PRE><tex2html_verbatim_mark>verbatim304#</PRE>

<P>
The  <#3528#><TT>instance_of?</TT><#3528#>  method does the same thing and is a little more elegant:

<P>
<PRE><tex2html_verbatim_mark>verbatim305#</PRE>

<P>
Usually when we test the class of an object, we would also like to
know if the object is an instance of any subclass of that class.
To test this, use the  <#3529#><TT>is_a?</TT><#3529#>  method, or its synonym  <#3530#><TT>kind_of?</TT><#3530#> :

<P>
<PRE><tex2html_verbatim_mark>verbatim306#</PRE>

<P>
The <A NAME="tex2html151"
  HREF="http://ruby-doc.org/core-2.0.0/Class.html"><TT>Class</TT></A><#3183#><#3183#> class defines the  <#3534#><TT>===</TT><#3534#>  operator in such a way that it can
be used in place of <tex2html_verb_mark>123<tex2html_verb_mark>:

<P>
<PRE><tex2html_verbatim_mark>verbatim307#</PRE>

<P>

<H4><A NAME="SECTION02384010000000000000">
Clase y Vida de un Objeto</A>
</H4>
  <TABLE CELLPADDING=3>
</TABLE>


<P>
Every object has a well-defined class in Ruby, and that class never
changes during the lifetime of the object. 

<P>

<H4><A NAME="SECTION02384020000000000000">
Que es un Tipo</A>
</H4>
  <TABLE CELLPADDING=3>
</TABLE>

When we talk
about the <A NAME="3543"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textit">type</SPAN> of an object, we mean <#3190#><I>the set of behaviors that
characterize the object</I><#3190#>

<P>
Another way to put it is that <#3191#><I>the type of
an object is the set of methods it can respond to</I><#3191#>

<P>
(This definition
becomes recursive because it is not just the name of the methods
that matter, but also the types of arguments that those methods can
accept.)

<P>

<H4><A NAME="SECTION02384030000000000000">
¿Puedo llamar a este método sobre este objeto?</A>
</H4>
  <TABLE CELLPADDING=3>
</TABLE>
 

<P>
In Ruby programming, we often don't care about the class of an
object, we just want to know whether we can invoke some method on
it. 

<P>

<OL>
<LI>Consider, for example, the <tex2html_verb_mark>124<tex2html_verb_mark> operator. 

<P>
Arrays, strings, files,
and other I/O-related classes define this as an append operator.

<P>
If we are writing a method that produces textual output, we might
write it generically to use this operator. 

<P>
</LI>
<LI>Then our method can be
invoked with any argument that implements <tex2html_verb_mark>125<tex2html_verb_mark>. We don't care about
the class of the argument, just that we can append to it. We can
test for this with the  <#3549#><TT>respond_to?</TT><#3549#>  method:

<P>
<PRE><tex2html_verbatim_mark>verbatim308#</PRE>
</LI>
<LI>Este método funciona tanto con cadenas como con arrays, listas, etc. es un método
polimorfo.  Polymorphism is the provision of a single interface to entities of different types.
</LI>
</OL>

<P>
The shortcoming of this approach is that it only checks the name
of a method, not the arguments for that method:

<OL>
<LI>For example, <A NAME="tex2html152"
  HREF="http://ruby-doc.org/core-2.0.0/Fixnum.html"><TT>Fixnum</TT></A><#3199#><#3199#>
and <A NAME="tex2html153"
  HREF="http://ruby-doc.org/core-2.0.0/Bignum.html"><TT>Bignum</TT></A><#3200#><#3200#> implement <tex2html_verb_mark>126<tex2html_verb_mark> as a left-shift operator and expect the
argument to be a number instead of a string. 

<P>
</LI>
<LI>Integer objects appear
to be <#3201#><I>appendable</I><#3201#> when we use a  <#3556#><TT>respond_to?</TT><#3556#>  test, 
but they produce
an error when our code appends a string. 
</LI>
</OL>

<P>
There is no general solution
to this problem, but an ad-hoc remedy, in this case, is to explicitly
rule out <A NAME="tex2html154"
  HREF="http://ruby-doc.org/core-2.0.0/Numeric.html"><TT>Numeric</TT></A><#3204#><#3204#> objects with the <tex2html_verb_mark>127<tex2html_verb_mark> method:

<P>
<PRE><tex2html_verbatim_mark>verbatim309#</PRE>

<P>
Another example of the <A NAME="3560"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textit">type-versus-class</SPAN> distinction is the 
<A NAME="tex2html155"
  HREF="http://ruby-doc.org/core-2.0.0/StringIO.html"><TT>StringIO</TT></A><#3208#><#3208#>
class (from Ruby's standard library). 

<P>

<OL>
<LI><A NAME="tex2html156"
  HREF="http://ruby-doc.org/core-2.0.0/StringIO.html"><TT>StringIO</TT></A><#3210#><#3210#> enables reading from
and writing to string objects as if they were <A NAME="tex2html157"
  HREF="http://ruby-doc.org/core-2.0.0/IO.html"><TT>IO</TT></A><#3211#><#3211#> objects. 

<P>
</LI>
<LI><A NAME="tex2html158"
  HREF="http://ruby-doc.org/core-2.0.0/StringIO.html"><TT>StringIO</TT></A><#3212#><#3212#>
mimics the <A NAME="tex2html159"
  HREF="http://ruby-doc.org/core-2.0.0/IO.html"><TT>IO</TT></A><#3213#><#3213#> API—<A NAME="tex2html160"
  HREF="http://ruby-doc.org/core-2.0.0/StringIO.html"><TT>StringIO</TT></A><#3214#><#3214#> objects define the same methods that <A NAME="tex2html161"
  HREF="http://ruby-doc.org/core-2.0.0/IO.html"><TT>IO</TT></A><#3215#><#3215#>
objects do. 

<P>
</LI>
<LI>But <A NAME="tex2html162"
  HREF="http://ruby-doc.org/core-2.0.0/StringIO.html"><TT>StringIO</TT></A><#3216#><#3216#> is not a subclass of <A NAME="tex2html163"
  HREF="http://ruby-doc.org/core-2.0.0/IO.html"><TT>IO</TT></A><#3217#><#3217#>. 

<P>
</LI>
<LI>If you write a
method that expects a stream argument, and test the class of the
argument with <tex2html_verb_mark>128<tex2html_verb_mark> <A NAME="tex2html164"
  HREF="http://ruby-doc.org/core-2.0.0/IO.html"><TT>IO</TT></A><#3218#><#3218#>, then your method won't work with <A NAME="tex2html165"
  HREF="http://ruby-doc.org/core-2.0.0/StringIO.html"><TT>StringIO</TT></A><#3219#><#3219#>
arguments.
</LI>
</OL>

<P>
Focusing on types rather than classes leads to a programming style
known in Ruby as ;SPMquot;duck typing.;SPMquot; 

<P>
Repasa la sección <#3221#><I>Comprobación de Tipos y Tipado Pato (Duck Typing)</I><#3221#>
<A HREF=<tex2html_cr_mark>#subsub:tiposypatos#3222><tex2html_cr_mark></A>.

<P>
El tipo de un objeto es el conjunto de conductas que caracterizan al objeto.
Es el conjunto de métodos a los que puede responder.

<P>
