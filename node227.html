
<H2><A NAME="SECTION02812000000000000000">
Definiendo Clases y Módulos</A>
</H2>

<P>
Las clases y los módulos son instancias de las clases <A NAME="9666"><tex2html_anchor_invisible_mark></A><A NAME="tex2html435"
  HREF="http://ruby-doc.org/core-2.0.0/Class.html"><TT>Class</TT></A>
y <A NAME="9670"><tex2html_anchor_invisible_mark></A><A NAME="tex2html436"
  HREF="http://ruby-doc.org/core-2.0.0/Module.html"><TT>Module</TT></A>.
Por tanto, es posible crearlos dinámicamente:
<PRE><tex2html_verbatim_mark>verbatim1006#</PRE>

<P>
Cuando un módulo o clase dinámicamente creado es asignado a una constante el nombre de esa 
constante es usado como nombre del módulo o clase.

<P>
<PRE><tex2html_verbatim_mark>verbatim1007#</PRE>

<UL>
<LI>Cuando una clase o módulo es creado dinámicamente y asignado a una constante, el nombre de la constante
es utilizado como nombre de la clase 

<P>
</LI>
<LI>Si fuera asignado a una
variable, el método <A NAME="9674"><tex2html_anchor_invisible_mark></A><A NAME="tex2html437"
  HREF="http://ruby-doc.org/core-2.0.0/Method.html#method-i-to_s"><TT>to_s</TT></A>
devolvería algo del estilo
<tex2html_verb_mark>1012<tex2html_verb_mark> y <A NAME="9678"><tex2html_anchor_invisible_mark></A><A NAME="tex2html438"
  HREF="http://ruby-doc.org/core-2.0.0/Module.html#method-i-name"><TT>name</TT></A>
devolvería <tex2html_verb_mark>1013<tex2html_verb_mark>.
</LI>
</UL>

<P>

<H3><A NAME="SECTION02812100000000000000"><tex2html_anchor_invisible_mark></A><A NAME="9688"><tex2html_anchor_invisible_mark></A><BR>
<A NAME="tex2html439"
  HREF="http://ruby-doc.org/core-2.0.0/Class.html"><TT>Class</TT></A>.new, <A NAME="tex2html440"
  HREF="http://ruby-doc.org/core-2.0.0/Module.html"><TT>Module</TT></A>.new, <A NAME="tex2html441"
  HREF="http://ruby-doc.org/core-2.0.0/Module.html#method-i-define_method"><TT>define_method</TT></A>
y Ambitos
</H3>

<P>

<OL>
<LI>El método <A NAME="9692"><tex2html_anchor_invisible_mark></A><A NAME="tex2html442"
  HREF="http://ruby-doc.org/core-2.0.0/Kernel.html#method-i-local_variables"><TT>local_variables</TT></A>
del módulo <A NAME="tex2html443"
  HREF="http://ruby-doc.org/core-2.0.0/Kernel.html"><TT>Kernel</TT></A><#8882#><#8882#> nos permite acceder
a las variables locales visibles en un punto.
</LI>
<LI>Algunos lenguajes permiten a un <A NAME="9699"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textbf">ámbito</SPAN> interno ver las variables
de un ámbito mas externo. Este tipo de visibilidad no ocurre en Ruby
</LI>
<LI>Hay tres puntos en los que un programa abandona el ámbito previo y
abre un nuevo ámbito (<A NAME="9701"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textbf">scope gates</SPAN> en al terminología del libro <SPAN  CLASS="textbf">Metaprogramming Ruby</SPAN>
[#metaprogramming#<tex2html_cite_mark>#1##<tex2html_cite_mark>#]):

<OL>
<LI>Definiciones de clase
</LI>
<LI>Definiciones de módulo
</LI>
<LI>Definiciones de método
</LI>
</OL>
</LI>
<LI>Las variables globales son visibles desde cualquier ámbito
</LI>
<LI>las variables de instancia son visibles desde cualquier punto en el que 
<tex2html_verb_mark>1014<tex2html_verb_mark> se refiere al mismo objeto
</LI>
</OL>

<P>
<tex2html_verbatim_mark>rawhtml1008#

<P>
Puesto que <A NAME="tex2html444"
  HREF="http://ruby-doc.org/core-2.0.0/Class.html"><TT>Class</TT></A><#8890#><#8890#>.new, <A NAME="tex2html445"
  HREF="http://ruby-doc.org/core-2.0.0/Module.html"><TT>Module</TT></A><#8891#><#8891#>.new y <A NAME="9709"><tex2html_anchor_invisible_mark></A><A NAME="tex2html446"
  HREF="http://ruby-doc.org/core-2.0.0/Module.html#method-i-define_method"><TT>define_method</TT></A>
usan el bloque que les sigue y los bloques no abandonan el <A NAME="9713"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textbf">ámbito</SPAN> previo (aunque 
crean uno nuevo),
podemos jugar con estos tres métodos para crear clausuras en las que se comparten
variables locales entre clases, métodos y ámbitos. Observe como en esta
reescritura del programa anterior cambia la visibilidad:

<P>
<tex2html_verbatim_mark>rawhtml1009#

<P>
