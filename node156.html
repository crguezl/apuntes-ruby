
<H1><A NAME="SECTION026120000000000000000"><tex2html_anchor_invisible_mark></A>
   <A NAME="5748"><tex2html_anchor_invisible_mark></A>
  
<A NAME="practica:regexpengine"><tex2html_anchor_mark></A><BR>
Práctica: Un Motor para las Expresiones Regulares en Pocas Líneas
</H1>

<P>

<H4><A NAME="SECTION026120010000000000000">
Objetivo</A>
</H4>
  <TABLE CELLPADDING=3>
</TABLE>


<P>
El objetivo es crear nuestro propio motor de expresiones regulares ([#friedl#<tex2html_cite_mark>#1##<tex2html_cite_mark>#]).
Para ello, una expresión regular como <tex2html_verb_mark>512<tex2html_verb_mark>
debe ser expresada mediante una lambda.
Una regexp como <tex2html_verb_mark>513<tex2html_verb_mark> es el resultado de la composición de lambdas. 
Por ejemplo, la regexp <tex2html_verb_mark>514<tex2html_verb_mark> se denotará por:

<P>
<PRE><tex2html_verbatim_mark>verbatim639#</PRE>

<P>

<H4><A NAME="SECTION026120020000000000000">
Como se hace</A>
</H4>
  <TABLE CELLPADDING=3>
</TABLE>


<P>
La idea es que <tex2html_verb_mark>515<tex2html_verb_mark>, <tex2html_verb_mark>516<tex2html_verb_mark>, <tex2html_verb_mark>517<tex2html_verb_mark>, etc. son métodos 
que retornan funciones (lambdas). La lambda retornada por <tex2html_verb_mark>518<tex2html_verb_mark> reconoce
el lenguaje <tex2html_verb_mark>519<tex2html_verb_mark>, la lambda retornada por <tex2html_verb_mark>520<tex2html_verb_mark> reconoce 
el lenguaje <tex2html_verb_mark>521<tex2html_verb_mark> y la lambda retornada por 
<tex2html_verb_mark>522<tex2html_verb_mark>
reconoce el lenguaje <tex2html_verb_mark>523<tex2html_verb_mark>.

<P>
Mas en concreto, <SPAN  CLASS="textit">la lambda que representa la expresión regular</SPAN> <tex2html_verb_mark>524<tex2html_verb_mark>

<OL>
<LI>recibe una cadena <tex2html_verb_mark>525<tex2html_verb_mark> y
</LI>
<LI>devuelve <tex2html_verb_mark>526<tex2html_verb_mark> <SPAN  CLASS="textit">si no hay un prefijo de</SPAN> <tex2html_verb_mark>527<tex2html_verb_mark> <SPAN  CLASS="textit">que case con</SPAN> <tex2html_verb_mark>528<tex2html_verb_mark>
</LI>
<LI>y devuelve <SPAN  CLASS="textit">el resto no casado de la cadena</SPAN> <tex2html_verb_mark>529<tex2html_verb_mark> <SPAN  CLASS="textit">si hubo matching</SPAN>
</LI>
</OL>

<P>
Por ejemplo, el método <tex2html_verb_mark>530<tex2html_verb_mark> recibe una cadena <tex2html_verb_mark>531<tex2html_verb_mark> 
y retorna una lambda que recibe una
cadena <tex2html_verb_mark>532<tex2html_verb_mark> y 

<P>

<OL>
<LI>devuelve <tex2html_verb_mark>533<tex2html_verb_mark> si  <tex2html_verb_mark>534<tex2html_verb_mark> no es un prefijo de <tex2html_verb_mark>535<tex2html_verb_mark>.
</LI>
<LI>En caso contrario retorna el resto de la cadena 
</LI>
</OL>
Esta implementación de <tex2html_verb_mark>536<tex2html_verb_mark> usa circuito corto:
<PRE><tex2html_verbatim_mark>verbatim640#</PRE>

<P>

<H4><A NAME="SECTION026120030000000000000">
Ejemplos de uso del Módulo</A>
</H4>
  <TABLE CELLPADDING=3>
</TABLE>


<P>
<PRE><tex2html_verbatim_mark>verbatim641#</PRE>

<P>
La siguiente secuencia de llamadas:
<PRE><tex2html_verbatim_mark>verbatim642#</PRE>
Debería producir una salida parecida a esta:
<PRE><tex2html_verbatim_mark>verbatim643#</PRE>

<P>

<H4><A NAME="SECTION026120040000000000000">
Definiendo Operadores</A>
</H4>
  <TABLE CELLPADDING=3>
</TABLE>


<P>
Es posible usar overriding de operadores para mejorar la expresividad
de la notación. He aqui un ejemplo que utiliza una versión en la que se han
definido los operadores:

<UL>
<LI><tex2html_verb_mark>537<tex2html_verb_mark> es <tex2html_verb_mark>538<tex2html_verb_mark>
</LI>
<LI><tex2html_verb_mark>539<tex2html_verb_mark> es <tex2html_verb_mark>540<tex2html_verb_mark>
</LI>
<LI><tex2html_verb_mark>541<tex2html_verb_mark> unario es <tex2html_verb_mark>542<tex2html_verb_mark>
</LI>
<LI><tex2html_verb_mark>543<tex2html_verb_mark> es <tex2html_verb_mark>544<tex2html_verb_mark>
</LI>
<LI>El método <tex2html_verb_mark>545<tex2html_verb_mark> es una versión de <tex2html_verb_mark>546<tex2html_verb_mark>
</LI>
</UL>
<PRE><tex2html_verbatim_mark>verbatim644#</PRE>
Cuando se ejecuta, este programa produce:
<PRE><tex2html_verbatim_mark>verbatim645#</PRE>

<P>

<H4><A NAME="SECTION026120050000000000000">
Tareas</A>
</H4>
  <TABLE CELLPADDING=3>
</TABLE>

<SPAN  CLASS="textit">Escriba un módulo que implementa este motor de expresiones regulares</SPAN>. Use <tex2html_verb_mark>547<tex2html_verb_mark> para 
que el espacio de nombres sea incluíble
(véase la sección <A HREF=<tex2html_cr_mark>#subsection:modulosespaciodenombresincluibles#5214><tex2html_cr_mark></A> de los apuntes):
<PRE><tex2html_verbatim_mark>verbatim646#</PRE>

<OL>
<LI>Use TDD con <A NAME="tex2html333"
  HREF="http://rspec.info/"><TT>RSpec</TT></A><#5218#><#5218#>
</LI>
<LI>Use Unit Testing
</LI>
<LI>Use Continuous Integration (Travis)
</LI>
<LI>Use Continuous Testing (Guard)
</LI>
<LI>Documente su gema (véase
<A NAME="tex2html334"
  HREF="http://docs.seattlerb.org/rdoc/RDoc/Markup.html"><SPAN  CLASS="textit">RDOC::Markup</SPAN></A>
o
<A NAME="tex2html335"
  HREF="http://rdoc.sourceforge.net/doc/index.html"><SPAN  CLASS="textit">RDOC</SPAN></A>
o 
<A NAME="tex2html336"
  HREF="http://yardoc.org"><SPAN  CLASS="textit">YARD</SPAN></A>). 
</LI>
<LI>Véa un ejemplo ilustrativo de como debería quedar la documentación del
módulo creado en <A NAME="tex2html337"
  HREF="rdoc_example/index.html">module ULL::ETSII::AluXXX::LambdaRegexp</A>
</LI>
<LI>Cree una gema <tex2html_verb_mark>548<tex2html_verb_mark>
</LI>
<LI>Publique la gema en <A NAME="tex2html338"
  HREF="https://rubygems.org/"><TT>RubyGems.org</TT></A><#5227#><#5227#>
</LI>
<LI>Indique la URL de su repositorio en <A NAME="tex2html339"
  HREF="http://help.github.com">GitHub</A><#5228#><#5228#>
</LI>
</OL>

<P>

<H4><A NAME="SECTION026120060000000000000">
Enlaces Relacionados</A>
</H4>
  <TABLE CELLPADDING=3>
</TABLE>


<UL>
<LI><A NAME="tex2html340"
  HREF="https://bitbucket.org/casiano/lambda-regexp/src">Casiano lambda-regexp project</A>
(bitbucket)
</LI>
</UL>
<tex2html_endfile>#./chapter6/metodos_procs_lambdas_y_clausuras.tex#

<P>
