
<H2><A NAME="SECTION02772000000000000000">
Los Módulos como Mixins</A>
</H2>

<P>
<BLOCKQUOTE>
</BLOCKQUOTE>
<OL>
<LI>Modules have another, wonderful use. 

<P>
At a stroke, they pretty much eliminate the need for inheritance, providing a facility called a <A NAME="tex2html387"
  HREF="http://en.wikipedia.org/wiki/Mixin">mixin</A>.

<P>
</LI>
<LI><#7228#><I>What happens if I define instance methods within a module?</I><#7228#> 

<P>
<DIV ALIGN="CENTER">
Good question 
</DIV> 

<P>
</LI>
<LI>A module can’t have instances, because a module isn’t a class. 

<P>
</LI>
<LI>However, you can <tex2html_verb_mark>829<tex2html_verb_mark> a module within a class definition. 

<P>
When this happens, all the module’s instance methods are suddenly available as methods in the class as well. 

<P>
</LI>
<LI>They get <A NAME="tex2html388"
  HREF="http://en.wikipedia.org/wiki/Mixin">mixed in</A>. 

<P>
</LI>
<LI>In fact, mixed-in modules effectively behave as superclasses.
</LI>
</OL><BLOCKQUOTE>
</BLOCKQUOTE>
<P>
<BLOCKQUOTE><DIV ALIGN="RIGHT"><#7234#>DaveThomas<#7234#>

</BLOCKQUOTE>
Si un módulo define métodos de instancia en vez de métodos de clase,
esos métodos de instancia pueden ser combinados/mezclados (<A NAME="7706"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textbf">mixin</SPAN>)
en otras clases.

<P>
Para mezclar un módulo en una clase llamamos al método <A NAME="7708"><tex2html_anchor_invisible_mark></A><SPAN  CLASS="textbf">include</SPAN>:
<PRE><tex2html_verbatim_mark>verbatim888#</PRE>

<P>

<OL>
<LI>Thanks to the magic of mixins and module <tex2html_verb_mark>830<tex2html_verb_mark>.
 All you have to do is write an iterator called <tex2html_verb_mark>831<tex2html_verb_mark>, which returns the elements of your collection in turn.
Mix in <tex2html_verb_mark>832<tex2html_verb_mark>, and suddenly your class supports things such as <tex2html_verb_mark>833<tex2html_verb_mark>, <tex2html_verb_mark>834<tex2html_verb_mark>, and <tex2html_verb_mark>835<tex2html_verb_mark>.
</LI>
<LI>If the objects in your collection implement meaningful ordering semantics using the <tex2html_verb_mark>836<tex2html_verb_mark> method, you’ll also get methods such as <tex2html_verb_mark>837<tex2html_verb_mark>, <tex2html_verb_mark>838<tex2html_verb_mark>, and <tex2html_verb_mark>839<tex2html_verb_mark>.
</LI>
</OL>

<P>
<A NAME="7710"><tex2html_anchor_invisible_mark></A><A NAME="tex2html389"
  HREF="http://ruby-doc.org/core-2.0.0/Module.html#method-i-include"><TT>include</TT></A>
es un método privado de instancia de <A NAME="tex2html390"
  HREF="http://ruby-doc.org/core-2.0.0/Module.html"><TT>Module</TT></A><#7243#><#7243#>:

<P>
<PRE><tex2html_verbatim_mark>verbatim889#</PRE>
Es legal incluir un módulo en una clase o en un  módulo.
Al hacerlo los métodos de instancia del módulo incluído
se convierten en métodos de instancia del incluyente.

<P>
<PRE><tex2html_verbatim_mark>verbatim890#</PRE>

<P>
<BLOCKQUOTE>
</BLOCKQUOTE>

We’ll make a couple of points about the <tex2html_verb_mark>840<tex2html_verb_mark> statement before we go on.
<OL>
<LI>First, it has nothing to do with files.
</LI>
<LI>C programmers use a preprocessor directive called <tex2html_verb_mark>841<tex2html_verb_mark> to insert the contents of one file into another during compilation.
 The Ruby <tex2html_verb_mark>842<tex2html_verb_mark> statement simply makes a reference to a module.
</LI>
<LI>If that module is in a separate file, you must use <tex2html_verb_mark>843<tex2html_verb_mark> 
(or its less commonly used cousin, <tex2html_verb_mark>844<tex2html_verb_mark>) to drag that file in before using <tex2html_verb_mark>845<tex2html_verb_mark>.
</LI>
<LI>Second, a Ruby <tex2html_verb_mark>846<tex2html_verb_mark> does not simply copy the module’s instance methods into the class.
 Instead, it makes a reference from the class to the included module.
</LI>
<LI>If multiple classes <tex2html_verb_mark>847<tex2html_verb_mark> that module, <SPAN ID="txt7250">they’ll all point to the same thing</SPAN>.
</LI>
<LI>If you change the definition of a method within a module, even while your program is running, all classes that <tex2html_verb_mark>848<tex2html_verb_mark> that module will exhibit the new behavior.
</LI>
</OL><BLOCKQUOTE>
</BLOCKQUOTE>
<P>
<BLOCKQUOTE><DIV ALIGN="RIGHT"><#7252#>Dave Thomas<#7252#>

</BLOCKQUOTE>

<P>

<H3><A NAME="SECTION02772100000000000000">
Variables de Instancia en Mixins</A>
</H3>

<P>
<BLOCKQUOTE>
</BLOCKQUOTE>
<OL>
<LI>Remember how instance variables work in Ruby: the first mention of an <tex2html_verb_mark>849<tex2html_verb_mark>-prefixed variable creates the instance variable in the current object, <tex2html_verb_mark>850<tex2html_verb_mark>.

<P>
</LI>
<LI>For a mixin, this means that the module you mix into your client class  may create instance variables in the client object and may use <tex2html_verb_mark>851<tex2html_verb_mark> and friends to define accessors for these instance variables. 
</LI>
<LI>However, this behavior exposes us to a risk. A mixin’s instance variables can clash with those of the host class or with those of other mixins. 
</LI>
</OL><BLOCKQUOTE>
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>The example that follows shows a class that uses our <tex2html_verb_mark>852<tex2html_verb_mark> module but that unluckily also uses an instance variable called <tex2html_verb_mark>853<tex2html_verb_mark>.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE></BLOCKQUOTE><PRE><tex2html_verbatim_mark>verbatim891#</PRE><BLOCKQUOTE>
</BLOCKQUOTE>
<P>
<BLOCKQUOTE></BLOCKQUOTE><PRE><tex2html_verbatim_mark>verbatim892#</PRE><BLOCKQUOTE>
At runtime, this program will go wrong in some hard-to-diagnose ways.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE></BLOCKQUOTE>
<OL>
<LI>For the most part, <#7263#><I>mixin modules don’t use instance variables directly—they use accessors to retrieve data from the client object</I><#7263#>
</LI>
<LI>But if you need to create a mixin that has to have its own state, ensure that the <#7264#><I>instance variables have unique names to distinguish them from any other mixins in the system</I><#7264#> 
(perhaps <SPAN ID="txt7265">by using the module’s name as part of the variable name</SPAN>).
</LI>
<LI>Alternatively, <#7266#><I>the module could use a module-level hash, 
indexed by the current object ID, 
to store instance-specific data</I><#7266#> 
without using Ruby instance variables.
A downside of this approach is that the data associated with a particular object will not get automatically deleted if the object is deleted.
</LI>
</OL><BLOCKQUOTE>
</BLOCKQUOTE>
<P>
<BLOCKQUOTE><DIV ALIGN="RIGHT"><#7268#>Dave Thomas<#7268#>

</BLOCKQUOTE>

<P>
<PRE><tex2html_verbatim_mark>verbatim893#</PRE>

<P>
<PRE><tex2html_verbatim_mark>verbatim894#</PRE>

<P>

<H3><A NAME="SECTION02772200000000000000"><tex2html_anchor_invisible_mark></A>
<A NAME="subsection:colisiones"><tex2html_anchor_mark></A><BR>
Colisiones
</H3>

<P>
<BLOCKQUOTE>
One of the other questions folks ask about mixins is, how is method lookup handled? In particular, what happens if methods with the same name are defined in a class, in that class’s parent class, and in a mixin included into the class?
</BLOCKQUOTE>
<P>
<BLOCKQUOTE></BLOCKQUOTE>
<OL>
<LI>The answer is that Ruby looks first in the immediate class of an object, 
</LI>
<LI>then in the mixins included into that class, 
</LI>
<LI>and then in superclasses and their mixins.
</LI>
<LI>If a class has multiple modules mixed in, the last one included is searched first.
</LI>
</OL><BLOCKQUOTE>
</BLOCKQUOTE>
<P>
<BLOCKQUOTE><DIV ALIGN="RIGHT"><#7279#>Dave Thomas<#7279#>

</BLOCKQUOTE>

<P>
¿Que ocurre si se incluyen dos módulos en los que existen métodos con el mismo nombre?
<PRE><tex2html_verbatim_mark>verbatim895#</PRE>

<P>
Cuando ambos módulos son incluídos en la clase <tex2html_verb_mark>854<tex2html_verb_mark>, la última definición de <tex2html_verb_mark>855<tex2html_verb_mark> es la que 
domina:
<PRE><tex2html_verbatim_mark>verbatim896#</PRE>

<P>
Ahora bien, si en la clase existe un método <tex2html_verb_mark>856<tex2html_verb_mark> ese será encontrado primero:
<PRE><tex2html_verbatim_mark>verbatim897#</PRE>

<P>

<H3><A NAME="SECTION02772300000000000000">
Composición frente a Herencia/Composition versus Inheritance</A>
</H3>

<P>
Inheritance and mixins both allow you to write code in one place and effectively inject that code into multiple classes. 

<P>
<DIV ALIGN="CENTER">
So, when do you use each?

</DIV>

<P>
<BLOCKQUOTE>
</BLOCKQUOTE>
<P>
<BLOCKQUOTE></BLOCKQUOTE>
<OL>
<LI>First, let’s look at subclassing. Classes in Ruby are related to the idea of types. 

<P>
</LI>
<LI>When we create our own classes, you can think of it as adding new types to the language. 

<P>
</LI>
<LI>And when we subclass either a built-in class or our own class, we’re creating a subtype.

<P>
</LI>
<LI>Now, a lot of research has been done on type theories. One of the more famous results is the Liskov Substitution Principle. Formally, this states: 

<P>
<BLOCKQUOTE>
Let q(x) be a property provable about objects x of type T. Then q(y) should be true for objects y of type S where S <tex2html_verb_mark>857<tex2html_verb_mark> subtype of T

</BLOCKQUOTE>

<P>
</LI>
<LI>What this means is that you should be able to substitute an object of a child class wherever you use an object of the parent class—the child should honor the parent’s contract. 

<P>
We’re used to saying this in English: a car <tex2html_verb_mark>858<tex2html_verb_mark> vehicle, a cat <tex2html_verb_mark>859<tex2html_verb_mark>n animal, and so on. 

<P>
This means that a cat should, at the very least, be capable of doing everything we say that an animal can do.

<P>
</LI>
<LI>So, when you’re looking for subclassing relationships while designing your application, be on the lookout for these 
<tex2html_verb_mark>860<tex2html_verb_mark> relationships.

<P>
</LI>
<LI>But...here’s the bad news. In the real world, there really aren’t that many true <tex2html_verb_mark>861<tex2html_verb_mark> relationships. 
Instead, it’s far more common to have <tex2html_verb_mark>862<tex2html_verb_mark> or <tex2html_verb_mark>863<tex2html_verb_mark> 
relationships between things. 
</LI>
</OL><BLOCKQUOTE>
</BLOCKQUOTE>
<P>
<BLOCKQUOTE><DIV ALIGN="RIGHT"><#7295#>Dave Thomas<#7295#>

</BLOCKQUOTE>

<P>

<OL>
<LI>Think of containment as a has a relationship. A car <tex2html_verb_mark>864<tex2html_verb_mark> engine, a person <tex2html_verb_mark>865<tex2html_verb_mark> name, etc.
</LI>
<LI>Think of inheritance as an <tex2html_verb_mark>866<tex2html_verb_mark> relationship. A car <tex2html_verb_mark>867<tex2html_verb_mark> vehicle, a person <tex2html_verb_mark>868<tex2html_verb_mark> mammal, etc.
</LI>
</OL>

<P>

<H3><A NAME="SECTION02772400000000000000"><tex2html_anchor_invisible_mark></A>
<A NAME="subsubsection:extend"><tex2html_anchor_mark></A><BR>
extend
</H3>

<P>
Aunque <tex2html_verb_mark>869<tex2html_verb_mark> es la forma normal de mezclar un módulo también es posible
mezclar con <tex2html_verb_mark>870<tex2html_verb_mark><A NAME="7717"><tex2html_anchor_invisible_mark></A><A NAME="tex2html391"
  HREF="http://ruby-doc.org/core-2.0.0/Object.html#method-i-extend"><TT>extend</TT></A>.
Este método hace que los métodos de instancia del módulo especificado se 
incorporen como métodos singleton del objeto receptor.
Si el objeto receptor es una clase, esto es, es un objeto de la clase <tex2html_verb_mark>871<tex2html_verb_mark>,
entonces los métodos son métodos de clase de dicha clase receptora.

<P>
<PRE><tex2html_verbatim_mark>verbatim898#</PRE>
Ejecución:
<PRE><tex2html_verbatim_mark>verbatim899#</PRE>

<P>
